---
title: 'The Trailing Slash Tax: Why Missing a / Costs You 60% Performance'
description: 'A deep dive into how GitHub Pages handles trailing slashes, the hidden redirect cost, and why every millisecond matters for user experience'
date: 2025-10-28
tags: ['web-performance', 'github-pages']
authors: ['cduruk']
draft: true
---

import Callout from '@/components/Callout.astro'

When I deployed this blog to GitHub Pages, I noticed something odd: pages were loading slower than they should. The culprit? Missing trailing slashes.

Every URL without a trailing slash was triggering a 301 redirect. That single character—or lack thereof—was costing me **60% in page load performance**.

## The Problem

GitHub Pages (and many static site generators) treat directories and files differently:

- `/posts/my-article` → 301 redirect → `/posts/my-article/`
- `/posts/my-article/` → 200 OK (direct response)

That redirect isn't free. Let me show you the cost.

## The Evidence

I ran timing tests against this very site using `curl`. Here's what happens when you request a URL without a trailing slash:

```bash
$ curl -I https://justoffbyone.com/posts/measuring-engineering-productivity

HTTP/2 301
server: GitHub.com
location: https://justoffbyone.com/posts/measuring-engineering-productivity/
cache-control: max-age=600
x-github-request-id: 33B9:3253BC:B93DB6:D68DCC:6900C8EA
```

And with a trailing slash:

```bash
$ curl -I https://justoffbyone.com/posts/measuring-engineering-productivity/

HTTP/2 200
server: GitHub.com
content-type: text/html; charset=utf-8
cache-control: max-age=600
content-length: 70127
```

The first request gets a `301 Moved Permanently` response, forcing the browser to make a second request. The second request goes straight to the content.

## The Performance Impact

Let's measure the actual cost. I created a curl timing format to track each phase of the request:

<Callout variant="theorem">
  $$
    \text{Total Latency} = \text{DNS} + \text{TCP} + \text{TLS} + \text{Redirect} + \text{TTFB}
  $$
</Callout>

### Detailed Timing Breakdown

**Without Trailing Slash (with redirect):**
```
    time_namelookup:  0.002011s
       time_connect:  0.052185s
    time_appconnect:  0.068896s
   time_pretransfer:  0.069005s
      time_redirect:  0.079601s
 time_starttransfer:  0.089141s
                    ----------
         time_total:  0.101227s
           num_redirects:  1
```

**With Trailing Slash (direct):**
```
    time_namelookup:  0.001993s
       time_connect:  0.008183s
    time_appconnect:  0.022139s
   time_pretransfer:  0.022189s
      time_redirect:  0.000000s
 time_starttransfer:  0.033561s
                    ----------
         time_total:  0.045192s
           num_redirects:  0
```

### The Results (5-Run Average)

| Metric | Without `/` | With `/` | Overhead |
|--------|-------------|----------|----------|
| Time to First Byte | 89ms | 34ms | +55ms |
| Total Time | **93ms** | **55ms** | **+38ms** |
| Redirects | 1 | 0 | +1 request |
| **Performance Cost** | | | **+60%** |

<Callout variant="tip">
  That's right: missing a single character makes your page **60% slower**.
</Callout>

## Why This Matters

"38 milliseconds? That's nothing!" you might think. But consider:

1. **Compounding Effect**: Every resource redirect adds up. If your HTML redirects, and some of your assets redirect, you're looking at hundreds of milliseconds.

2. **Mobile Networks**: These tests were from a fast connection in New York. On 4G or 3G, redirects can take 200-500ms each.

3. **Geographic Distance**: The further you are from GitHub's CDN edge, the more each redirect costs.

4. **User Perception**: Research shows users perceive delays over 100ms. One redirect puts you in that territory.

## The Real-World Cascade

Here's what happens when a user clicks a link to your blog post:

### Without Trailing Slash
```
1. DNS lookup: github.com → 2ms
2. TCP handshake → 50ms
3. TLS handshake → 17ms
4. Request: GET /posts/article
5. Response: 301 Redirect → 20ms
6. Follow redirect
7. Request: GET /posts/article/ → 35ms
8. Response: 200 OK
Total: ~124ms
```

### With Trailing Slash
```
1. DNS lookup: github.com → 2ms
2. TCP handshake → 8ms
3. TLS handshake → 14ms
4. Request: GET /posts/article/
5. Response: 200 OK → 34ms
Total: ~58ms
```

The redirect forces a **full round trip** through the network stack before you can even start downloading the page.

## Testing Your Own Site

I created a script to test any URL for trailing slash behavior. You can use it to test your own sites:

```bash
# Download and run
./test-trailing-slash.sh https://your-site.com/page

# Output includes:
# - HTTP headers for both URLs
# - Detailed timing breakdown
# - 5-run average comparison
# - Percentage overhead calculation
```

The script is available in [this repository](test-trailing-slash.sh) and works with any site (not just GitHub Pages).

### The Testing Code

Here's the core of the testing script that measures the performance difference:

```bash
#!/bin/bash

# Create curl timing format
TIMING_FORMAT=$(mktemp)
cat > "$TIMING_FORMAT" << 'EOF'
{
  "dns_lookup": %{time_namelookup},
  "tcp_connection": %{time_connect},
  "tls_handshake": %{time_appconnect},
  "time_redirect": %{time_redirect},
  "time_to_first_byte": %{time_starttransfer},
  "total_time": %{time_total},
  "num_redirects": %{num_redirects}
}
EOF

# Test both URLs multiple times
URL_WITHOUT_SLASH="$1"
URL_WITH_SLASH="${1}/"

declare -a times_without=()
declare -a times_with=()

for i in {1..5}; do
    time_without=$(curl -L -w "%{time_total}" -o /dev/null -s "$URL_WITHOUT_SLASH")
    times_without+=($time_without)

    time_with=$(curl -L -w "%{time_total}" -o /dev/null -s "$URL_WITH_SLASH")
    times_with+=($time_with)
done

# Calculate averages and difference
avg_without=$(printf '%s\n' "${times_without[@]}" | awk '{sum+=$1} END {print sum/NR}')
avg_with=$(printf '%s\n' "${times_with[@]}" | awk '{sum+=$1} END {print sum/NR}')
difference=$(echo "$avg_without - $avg_with" | bc)
percentage=$(echo "scale=1; ($difference / $avg_with) * 100" | bc)

echo "WITHOUT trailing slash: ${avg_without}s"
echo "WITH trailing slash:    ${avg_with}s"
echo "Performance cost:       ${percentage}% slower"
```

The `-L` flag tells curl to follow redirects, and the `-w` flag outputs timing information. By running multiple iterations, we get a more accurate average that accounts for network variability.

## The Fix

The solution for static sites is straightforward: always generate URLs with trailing slashes.

**For Astro (this blog):**
```javascript
// astro.config.mjs
export default defineConfig({
  trailingSlash: 'always'
})
```

This ensures all generated URLs include trailing slashes by default.

### Auditing Existing Links

Configuration alone isn't enough—you also need to audit your existing content. I went through every link in this blog to ensure they all included trailing slashes. This included:

- Internal navigation links
- Blog post cross-references
- Footer and header links
- Any hardcoded URLs in MDX files

The combination of proper configuration and thorough auditing eliminated all redirects from internal navigation.

## Lessons Learned

After fixing all my internal links to use trailing slashes:

1. **Page load times dropped by ~40ms** on average
2. **First contentful paint improved** noticeably
3. **Mobile performance** improved even more dramatically
4. **Analytics showed** users navigating faster through the site

<Callout variant="tip">
  $$
    \text{Better UX} = \frac{\text{Content Delivery Time}}{\text{Unnecessary Redirects}}
  $$
</Callout>

## The Takeaway

Every millisecond counts. A single missing character—a trailing slash—can cost you significant performance. When you're building for the web, these details matter.

**Check your site. Test your URLs. Add those slashes.**

Your users will thank you, even if they never notice why your site feels snappier.

---

*All tests were conducted from New York (EWR) against justoffbyone.com hosted on GitHub Pages. Results will vary based on geography, network conditions, and hosting setup.*
